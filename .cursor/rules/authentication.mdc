---
description: 
globs: 
alwaysApply: true
---
# Authentication System Documentation

## Overview

The authentication system in withme.travel uses Supabase Auth with secure cookie-based sessions. It leverages Next.js 15's latest patterns and `@supabase/supabase-js` for robust, maintainable authentication.

The core architecture consists of:

- **Auth Provider**: A centralized React context that manages auth state
- **Server Utilities**: Helper functions for authentication in server components and API routes
- **Client Hooks**: Easy-to-use hooks for authentication in client components
- **Profile Integration**: Automatic connection between auth users and profile data
- **Error Handling**: Graceful error recovery for authentication failures

## Key Components and Best Practices

### 1. Auth Provider (`./components/auth-provider.tsx`)

The Auth Provider is the heart of our authentication system. It manages user sessions, handles state, and provides authentication methods to client components.

```tsx
// In layout.tsx
import { AuthProvider } from '@/components/auth-provider';

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <AuthProvider>{children}</AuthProvider>
      </body>
    </html>
  );
}
```

**Best Practices**:

- The provider should handle session refreshes automatically
- User state should include profile data when available
- Error handling should be consistent and user-friendly
- Use a simple, maintainable implementation without complex state management

### 2. Server Authentication

Server-side authentication in Next.js 15 requires proper cookie handling and session management. We provide utility functions that make this easy:

```tsx
// In utils/supabase/server.ts
import { createClient } from '@supabase/supabase-js';
import { cookies } from 'next/headers';

// Use this in server components and API routes
export async function getServerSession() {
  const cookieStore = cookies();
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      auth: {
        persistSession: false,
        autoRefreshToken: false,
      },
      cookies: {
        async get(name) {
          return cookieStore.get(name)?.value;
        },
        // Other cookie handlers
      },
    }
  );

  return await supabase.auth.getSession();
}
```

**Best Practices**:

- Always use the correct cookie handlers for server environments
- Set `persistSession: false` for server environments
- Create reusable utility functions for common auth tasks
- Handle errors gracefully with proper status codes and messages

### 3. Client Authentication Hook

The `useAuth` hook provides simple access to authentication state and methods in client components:

```tsx
// Example: Using auth in a client component
'use client';
import { useAuth } from '@/components/auth-provider';

export default function ProfileButton() {
  const { user, isLoading, signOut } = useAuth();

  if (isLoading) return <Spinner />;

  if (!user) {
    return <SignInButton />;
  }

  return (
    <div>
      <p>Welcome, {user.profile?.name || user.email}</p>
      <button onClick={signOut}>Sign Out</button>
    </div>
  );
}
```

**Best Practices**:

- Always add 'use client' directive in components using the hook
- Handle loading states for better user experience
- Provide clear error messages for authentication failures
- Extract complex auth logic into separate functions

### 4. Route Protection in Next.js 15

In Next.js 15, protecting routes requires special handling, especially with dynamic routes:

```tsx
// In app/protected/[id]/page.tsx
export default async function ProtectedPage({ params }: { params: Promise<{ id: string }> }) {
  // Must await params in Next.js 15 before using them
  const { id } = await params;

  // Check authentication
  const {
    data: { session },
  } = await getServerSession();

  if (!session) {
    // Redirect to login
    redirect(`/login?redirectTo=${encodeURIComponent(`/protected/${id}`)}`);
  }

  // Continue with the authenticated page...
}
```

**Best Practices**:

- Always await dynamic route parameters before using them
- Use proper encoding for redirect URLs
- Create reusable auth check functions
- Add detailed logging for debugging auth issues

Handling Authentication in Client vs. Server Components

Server Components

Server components cannot use hooks, but can perform direct authentication checks:

````tsx
// Server component
import { getServerSession } from '@/utils/supabase/server';

export default async function ServerComponent() {
  const { data: { session } } = await getServerSession();

  if (!session) {
    return <NotAuthenticatedUI />;
  }

  return <AuthenticatedUI userId={session.user.id} />;
}```

Client Components

Client components can use the useAuth hook:
```'use client';
import { useAuth } from '@/components/auth-provider';

export default function ClientComponent() {
  const { user, signIn } = useAuth();

  // Use user data and auth methods...
}```

Authentication Error Handling

Proper error handling is crucial for a good user experience:

```// In a client component form
const handleLogin = async (e) => {
  e.preventDefault();
  setError(null);
  setLoading(true);

  try {
    await signIn(email, password);
    // Success - redirect or update UI
  } catch (error) {
    // Extract readable error message
    const message = error.message || 'Failed to sign in';
    setError(message.includes('credentials')
      ? 'Invalid email or password'
      : message);
  } finally {
    setLoading(false);
  }
};```

Server-side error handling:
```// In a server action or API route
try {
  const { data, error } = await supabase.auth.signInWithPassword({
    email, password
  });

  if (error) throw error;

  // Success
} catch (error) {
  console.error('Authentication error:', error);
  // Return appropriate error response
}```

Specific Next.js 15 Considerations

1. Awaiting Dynamic Route Parameters

Next.js 15 requires you to await route parameters before using them:

````

// BEFORE (Next.js 14)
export default function Page({ params }: { params: { id: string } }) {
const id = params.id; // Works in Next.js 14
}

// AFTER (Next.js 15)
export default async function Page({ params }: { params: Promise<{ id: string }> }) {
const { id } = await params; // Required in Next.js 15
}```

2. Cookie Handling

Next.js 15 has improved cookie handling through the cookies() API:

````import { cookies } from 'next/headers';

export async function GET() {
  const cookieStore = cookies();
  // Use cookieStore to get auth cookies
}```

3. Session Management in API Routes

API routes should use consistent authentication patterns:

````

export async function GET(request: Request) {
const { data: { session } } = await getServerSession();

if (!session) {
return Response.json({ error: 'Unauthorized' }, { status: 401 });
}

// Continue with authenticated request
}```

## API Authentication Routes

The system provides several key API routes for authentication:

// Note: The `/api/auth/csrf` endpoint has been removed since CSRF protection is no longer used.

- `/api/auth/login` - Handle login requests with CSRF validation
- `/api/auth/logout` - Handle logout requests and clear session data
- `/api/auth/signup` - Handle registration with proper validation
- `/api/auth/me` - Get current user data
- `/api/auth/clear-cookies` - Force clear authentication cookies (useful for troubleshooting)
- `/api/auth/forgot-password` - Handle password reset requests
- `/api/auth/reset-password` - Process password reset with token validation

Each route implements proper error handling, CSRF validation, and security measures.

## Future Authentication Enhancements

Planned improvements to the authentication system:

1. Multi-factor authentication support
2. More social login providers
3. Enhanced session analytics and monitoring
4. Improved account recovery flows
5. Progressive authentication with step-up capabilities

Troubleshooting

Common Issues:

1. "Not authenticated" redirects: Often caused by cookie issues or session expiry. Check cookie configuration in server.ts and ensure proper session handling.
2. Redirect loops: Can occur when redirect logic isn't properly handling authentication state. Add redirect counters or debug logs to track the flow.
3. Auth state not updating: The AuthProvider should update state when auth events occur. Check your event subscriptions.
4. Server/client auth mismatch: Ensure consistent session handling between server and client code.
5. Next.js 15 route parameter errors: Always await params objects before accessing properties.

Specific Trip Page Issues:

If experiencing issues with trip pages not loading:
• Ensure params are awaited before use: const { tripId } = await params;
• Check that the getServerSession() function is being used correctly
• Add diagnostic logging to see where authentiation checks might be failing
• Verify redirect URLs are properly encoded

Implementation Summary

Our authentication system:

• Uses Supabase Auth with secure cookie sessions
• Provides a clean, maintainable AuthProvider implementation
• Has clear separation between client and server authentication
• Handles Next.js 15's async route parameters properly
• Includes comprehensive error handling and recovery
• Simplifies authentication checks in both client and server contexts
• Avoids complexity that leads to bugs (no refresh locks, counters, etc.)
• Follows best practices for security and user experience

This approach ensures reliable authentication while maintaining code that's easy to understand and extend.
